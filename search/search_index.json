{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Acc\u00e9s a Dades"},{"location":"AD_T1_Sistema_de_fitxers/1_introducci/","text":"1.- Introducci\u00f3 Un fitxer o arxiu \u00e9s un conjunt de bits guardats en un dispositiu (com podria ser per exemple un disc dur). Els fitxers ens garantitzen la persist\u00e8ncia , ja que encara que apaguem l'ordinador podrem recuperar la informaci\u00f3, cosa que no passaria amb la informaci\u00f3 guardada en mem\u00f2ria RAM. El tema de la persist\u00e8ncia \u00e9s justament el que buscarem durant tot el curs. Un fitxer tindr\u00e0 un nom que l'identifica. Aquest nom pot tenir opcionalment una extensi\u00f3, generalment de 3 car\u00e0cters que tradicionalment ha servit per identificar el tipus de fitxer. El nom i l'extensi\u00f3 van separats per un punt. En els sistemes inform\u00e0tics actuals, en els quals un \u00fanic ordinador pot arribar a tenir guardats milions de fitxers, resulta imprescindible un sistema que permeta una gesti\u00f3 efica\u00e7 de localitzaci\u00f3, de manera que els usuaris puguem moure\u2019ns c\u00f2modament entre tants arxius. La major part de sistemes de fitxers han incorporat contenidors jerarquitzats que actuen a mode de directoris facilitant la classificaci\u00f3, la identificaci\u00f3 i localitzaci\u00f3 dels arxius. Els directoris s\u2019han acabat popularitzant sota la versi\u00f3 gr\u00e0fica de carpetes . Dins d'un mateix directori, el nom del fitxer (o subdirectori) ha de ser \u00fanic. Hem de tenir en compte, que a m\u00e9s dels fitxers guardats en el dispositiu de l'ordinador (el disc dur, o un altre dispositiu), la necessitat desmesurada d\u2019espai d\u2019emmagatzematge ha dut els Sistemes Operatius a treballar amb una gran quantitat de dispositius i a permetre l\u2019acc\u00e9s remot a uns altres sistemes de fitxers, distribu\u00efts per la xarxa. Per a poder gestionar tanta varietat de sistemes de fitxers, alguns sistemes operatius com Linux o Unix utilitzen l\u2019estrat\u00e8gia d\u2019unificar tots els sistemes en un \u00fanic sistema de fitxers , per tal d\u2019aconseguir una forma d\u2019acc\u00e9s unificada i amb una \u00fanica jerarquia que facilite la refer\u00e8ncia a qualsevol dels seus components, amb independ\u00e8ncia del dispositiu en el qual es troben realment ubicats. En Linux, siga quin siga el dispositiu o el sistema remot real on es guardar\u00e0 l\u2019arxiu, la ruta tindr\u00e0 sempre la mateixa forma . Observeu que per a rec\u00f3rrer la ruta jer\u00e0rquica on es troba el fitxer s'utilitza la barra de dividir : /dir_1/dir_2/dir_3/.../dir_n/fitxer.txt Per contra, l\u2019estrat\u00e8gia d\u2019altres Sistemes Operatius com Windows passa per mantenir ben diferenciats cadascun dels sistemes i dispositius on es tinga acc\u00e9s. Per distingir el sistema al qual es vol fer refer\u00e8ncia, Windows utilitza una denominaci\u00f3 espec\u00edfica del dispositiu o servidor, que incorpora a la ruta del fitxer o directori a referenciar. Encara que Microsoft ha apostat clarament per la convenci\u00f3 UNC ( Uniform Naming Convention ), l\u2019evoluci\u00f3 d\u2019aquest sistema operatiu, que t\u00e9 com a origen l\u2019MS-DOS, ha fet que coexistesca amb una altra convenci\u00f3 tamb\u00e9 molt estesa, la que utilitza una lletra de l\u2019alfabet seguida de dos punts per a identificar el dispositiu on es troba el fitxer. A continuaci\u00f3 il\u00b7lustrem amb un exemple les dues convencions. Observeu com en els dos casos s'utilitza la contra-barra : F:\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt \\\\\\Servidor_1\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1. Introducci\u00f3"},{"location":"AD_T1_Sistema_de_fitxers/1_introducci/#1-introduccio","text":"Un fitxer o arxiu \u00e9s un conjunt de bits guardats en un dispositiu (com podria ser per exemple un disc dur). Els fitxers ens garantitzen la persist\u00e8ncia , ja que encara que apaguem l'ordinador podrem recuperar la informaci\u00f3, cosa que no passaria amb la informaci\u00f3 guardada en mem\u00f2ria RAM. El tema de la persist\u00e8ncia \u00e9s justament el que buscarem durant tot el curs. Un fitxer tindr\u00e0 un nom que l'identifica. Aquest nom pot tenir opcionalment una extensi\u00f3, generalment de 3 car\u00e0cters que tradicionalment ha servit per identificar el tipus de fitxer. El nom i l'extensi\u00f3 van separats per un punt. En els sistemes inform\u00e0tics actuals, en els quals un \u00fanic ordinador pot arribar a tenir guardats milions de fitxers, resulta imprescindible un sistema que permeta una gesti\u00f3 efica\u00e7 de localitzaci\u00f3, de manera que els usuaris puguem moure\u2019ns c\u00f2modament entre tants arxius. La major part de sistemes de fitxers han incorporat contenidors jerarquitzats que actuen a mode de directoris facilitant la classificaci\u00f3, la identificaci\u00f3 i localitzaci\u00f3 dels arxius. Els directoris s\u2019han acabat popularitzant sota la versi\u00f3 gr\u00e0fica de carpetes . Dins d'un mateix directori, el nom del fitxer (o subdirectori) ha de ser \u00fanic. Hem de tenir en compte, que a m\u00e9s dels fitxers guardats en el dispositiu de l'ordinador (el disc dur, o un altre dispositiu), la necessitat desmesurada d\u2019espai d\u2019emmagatzematge ha dut els Sistemes Operatius a treballar amb una gran quantitat de dispositius i a permetre l\u2019acc\u00e9s remot a uns altres sistemes de fitxers, distribu\u00efts per la xarxa. Per a poder gestionar tanta varietat de sistemes de fitxers, alguns sistemes operatius com Linux o Unix utilitzen l\u2019estrat\u00e8gia d\u2019unificar tots els sistemes en un \u00fanic sistema de fitxers , per tal d\u2019aconseguir una forma d\u2019acc\u00e9s unificada i amb una \u00fanica jerarquia que facilite la refer\u00e8ncia a qualsevol dels seus components, amb independ\u00e8ncia del dispositiu en el qual es troben realment ubicats. En Linux, siga quin siga el dispositiu o el sistema remot real on es guardar\u00e0 l\u2019arxiu, la ruta tindr\u00e0 sempre la mateixa forma . Observeu que per a rec\u00f3rrer la ruta jer\u00e0rquica on es troba el fitxer s'utilitza la barra de dividir : /dir_1/dir_2/dir_3/.../dir_n/fitxer.txt Per contra, l\u2019estrat\u00e8gia d\u2019altres Sistemes Operatius com Windows passa per mantenir ben diferenciats cadascun dels sistemes i dispositius on es tinga acc\u00e9s. Per distingir el sistema al qual es vol fer refer\u00e8ncia, Windows utilitza una denominaci\u00f3 espec\u00edfica del dispositiu o servidor, que incorpora a la ruta del fitxer o directori a referenciar. Encara que Microsoft ha apostat clarament per la convenci\u00f3 UNC ( Uniform Naming Convention ), l\u2019evoluci\u00f3 d\u2019aquest sistema operatiu, que t\u00e9 com a origen l\u2019MS-DOS, ha fet que coexistesca amb una altra convenci\u00f3 tamb\u00e9 molt estesa, la que utilitza una lletra de l\u2019alfabet seguida de dos punts per a identificar el dispositiu on es troba el fitxer. A continuaci\u00f3 il\u00b7lustrem amb un exemple les dues convencions. Observeu com en els dos casos s'utilitza la contra-barra : F:\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt \\\\\\Servidor_1\\dir_1\\dir_2\\dir_3\\\\...\\dir_n\\fitxer.txt Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"1.- Introducci\u00f3"},{"location":"AD_T1_Sistema_de_fitxers/2_la_classe_file_generalitats/","text":"2.- La classe File. Generalitats. En Java, i tamb\u00e9 en Kotlin per ser una esp\u00e8cie d'extensi\u00f3 de Java, per a gestionar el sistema de fitxers s\u2019utilitza b\u00e0sicament la classe \u2018 File \u2019. \u00c9s una classe que s\u2019ha d\u2019entendre com una refer\u00e8ncia a la ruta o localitzaci\u00f3 de fitxers del sistema. NO representa el contingut de cap fitxer, sin\u00f3 la ruta del sistema on es localitza el fitxer. Com que es tracta d\u2019una ruta, la classe pot representar tant fitxers com carpetes o directoris . Si fem servir una classe per a representar rutes, s\u2019aconsegueix una total independ\u00e8ncia respecte de la notaci\u00f3 que utilitza cada sistema operatiu per descriure-les. Recordem que Java i Kotlin s\u00f3n llenguatges multiplataforma i, per tant, s'ha d'intentar fer programes que es puguen executar en qualsevol Sistema Operatiu (Windows o Linux). L\u2019estrat\u00e8gia utilitzada per cada SO no afecta la funcionalitat de la classe File , ja que aquesta, en col\u00b7laboraci\u00f3 amb la m\u00e0quina virtual, adaptar\u00e0 les sol\u00b7licituds al SO amfitri\u00f3 de forma transparent al programador , \u00e9s a dir, sense necessitat que el programador haja d\u2019indicar o configurar res. Els objectes creats de la classe File es troben estretament vinculats a la ruta amb la qual s\u2019han creat. Aix\u00f2 significa que les inst\u00e0ncies de la classe File durant tot el seu cicle de vida nom\u00e9s representaran una \u00fanica ruta, la que se\u2019ls va associar en el moment de la creaci\u00f3. La classe File no disposa de cap m\u00e8tode ni mecanisme per modificar la ruta associada. En cas de necessitar noves rutes, caldr\u00e0 sempre crear un nou objecte i no ser\u00e0 possible reutilitzar els ja creats vinculant-los a rutes diferents. Per a crear un objecte File es pot utilitzar qualsevol dels 3 constructors seg\u00fcents: File(String directori_i_fitxer ) : indiquem en un \u00fanic par\u00e0metre tant el directori com el fitxer, \u00e9s a dir, el fitxer amb la seua ruta. Recordeu que en sistemes Linux per a la ruta utilitzem la barra de dividir, mentre que en Windows la contra-barra. Com que aquest car\u00e0cter \u00e9s el d' escape , s'haur\u00e0 de posar dues vegades: val fitxer_1 = File(\"/home/usuari/AD/T1/exemple1.txt\") val fitxer_1 = File(\"C:\\\\\\AD\\\\\\T1\\\\\\exemple1.txt\") Nota Cap de les refer\u00e8ncies anteriors s\u00f3n desitjables, ja que nosaltres intentarem fer programes que funcionen en qualsevol plataforma, i la primera refer\u00e8ncia no funcionar\u00e0 en Windows, i la segona no funcionar\u00e0 en Linux. Al llarg del tema aprendrem com fer les refer\u00e8ncies de manera que funcionen en qualsevol plataforma. Per una altra banda, observeu com hem utilitzat la paraula reservada val per a crear una constant. Quasi sempre la utilitzarem per als File, ja que nom\u00e9s en algunes ocasions voldrem reutilitzar la variable assignant-li un altre valor Per a fer refer\u00e8ncia a un directori s'utilitza la mateixa t\u00e8cnica, com ja hav\u00edem vist: val dir = File(\"/home/usuari/AD/T1\") En els exemples anteriors hem posat una ruta absoluta, que comen\u00e7a des de l'arrel. Si no la posem absoluta (si no comen\u00e7a per / ) ser\u00e0 relativa i comen\u00e7ar\u00e0 en el directori actiu. Si suposem que el directori actiu \u00e9s /home/usuari , d'aquesta manera far\u00edem refer\u00e8ncia al mateix lloc: val dir = File(\"AD/T1\"); Nota Observeu que les anteriors sent\u00e8ncies no donarien cap error encara que els subdirectoris i fitxers no existisquen. No \u00e9s cap contradicci\u00f3, ja que podria ser que f\u00e9rem refer\u00e8ncia en un File a un fitxer o directori justament per a crear-lo. M\u00e9s avant veurem que tenim m\u00e8todes per a detectar l'exist\u00e8ncia real File(String directori , String fitxer ) : en el primer par\u00e0metre (String) indiquem el directori amb ruta, i en el segon el fitxer (sense ruta). Far\u00e0 refer\u00e8ncia a un fitxer amb el nom com el segon par\u00e0metre col\u00b7locat en el directori referenciat en el primer par\u00e0metre. Observeu com el segon par\u00e0metre podria ser tamb\u00e9 un directori, i per tant seria una refer\u00e8ncia a un subdirectori del directori referenciat en el primer par\u00e0metre. val fitxer_2 = File(\"/home/usuari/AD/T1\" , \"exemple2.txt\") File(File directori , String fitxer ) : Ara el directori \u00e9s un File creat anteriorment val fitxer_3 = File(dir , \"exemple3.txt\") En els exemples anteriors hem posat directament les rutes. Per\u00f2 els programadors de Java i de Kotlin han de fer un esfor\u00e7 per independitzar les aplicacions implementades de les plataformes on s\u2019executaran. Per tant, haurem d'anar amb cura, fent servir t\u00e8cniques que eviten escriure les rutes directament al codi. Per aix\u00f2 encara que ara al principi utilitzarem els 3 constructors, en el futur haur\u00edem d'utilitzar massivament el tercer, ja que com veieu la manera d'especificar la ruta de localitzaci\u00f3 del fitxer, \u00e9s per mig d'un altre File, i no ha fet falta posar cap barra de dividir ni cap contra-barra. Per tant hem fet refer\u00e8ncia a un fitxer (o subdirectori) dins d'un directori sense cap barra ni contra-barra , i per tant ens val per qualsevol Sistema Operatiu. La classe File encapsula pr\u00e0cticament tota la funcionalitat necess\u00e0ria per gestionar un sistema de fitxers organitzat en arbre de directoris. \u00c9s una gesti\u00f3 completa que inclou: Funcions de manipulaci\u00f3 i consulta de la pr\u00f2pia estructura jer\u00e0rquica (creaci\u00f3, eliminaci\u00f3, obtenci\u00f3 de la ubicaci\u00f3, etc. de fitxers o directoris) Funcions de manipulaci\u00f3 i consulta de les caracter\u00edstiques particulars dels elements (noms, mida o capacitat, etc.) Funcions de manipulaci\u00f3 i consulta d\u2019atributs espec\u00edfics de cada Sistema Operatiu, com per exemple els permisos d\u2019escriptura, d\u2019execuci\u00f3, atributs d\u2019ocultaci\u00f3. Nom\u00e9s funcionar\u00e0 si el sistema operatiu amfitri\u00f3 suporta tamb\u00e9 la funcionalitat d'aquestos atributs. En la classe original de Java no ens permet accedir al contingut dels fitxers. Aix\u00f2 es resoldr\u00e0 en el seg\u00fcent tema. Kotlin s\u00ed que ens permetr\u00e0 accedir al contingut dels fitxers a partir de la classe File, per\u00f2 per coher\u00e8ncia ho deixarem per al proper tema. Nota Tots els exemples i exercicis de cada tema els col\u00b7locarem en un \u00fanic projecte de Kotlin amb el nom del tema. en aquest cas l'anomenarem Tema1 . Els exemples els col\u00b7locarem en un paquet anomenat exemple i els exercicis en un paquet anomenat exercicis . En l'apartat Instala.laci\u00f3 de IntelliJ IDEA Ultimate d'aquest tema, hi ha un v\u00eddeo que explica la instal\u00b7laci\u00f3 de l'entorn de programaci\u00f3, i al final d'aquest v\u00eddeo s'explica com crear el projecte, els paquets exemples i exercicis i com copiar els programes en un fitxer Kotlin. Mirem un exemple. Anem a fer un programa per a traure la llista de fitxers i directoris del directori actual. Per a fer refer\u00e8ncia al directori actual, utilitzarem \".\", que ens serveix per a tots els Sistemes. Per defecte, el directori actiu \u00e9s el directori del projecte. Per a obtenir la llista d'elements (fitxers i directoris) utilitzarem el m\u00e8tode list() de la classe File . Veurem aquest m\u00e8tode, juntament amb els m\u00e8todes m\u00e9s importants en la seg\u00fcent pregunta. Copieu-vos el seg\u00fcent en un fitxer Kotlin anomenat Exemple_1_1.kt package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list()) println(e); } I aquest seria el resultat: que s\u00f3n els fitxers del directori arrel del projecte Tema1 (situat en la carpeta IdeaProjects ). Observeu que fins i tot mostra els fitxers ocults (que s\u00f3n els que comencen per un punt) I aprofitant la potencialitat de Kotlin, podem traure f\u00e0cilment aquesta llista ordenada alfab\u00e8ticament, senzillament posant .sorted() . D'aquesta manera, el programa anterior Exemple_1_1.kt ens quedar\u00e0 ara: package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list().sorted()) println(e); } I aquest seria el resultat: Si vulgu\u00e9rem traure el contingut d'un directori concret, el posar\u00edem en el moment de definir el File, en compte del punt per a indicar el directori actual. Una altra modificaci\u00f3 seria demanar per teclat el directori del qual volem mostrar el contingut. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_1_2.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.list().sorted()) System.out.println(e); } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2. La classe File. Generalitats."},{"location":"AD_T1_Sistema_de_fitxers/2_la_classe_file_generalitats/#2-la-classe-file-generalitats","text":"En Java, i tamb\u00e9 en Kotlin per ser una esp\u00e8cie d'extensi\u00f3 de Java, per a gestionar el sistema de fitxers s\u2019utilitza b\u00e0sicament la classe \u2018 File \u2019. \u00c9s una classe que s\u2019ha d\u2019entendre com una refer\u00e8ncia a la ruta o localitzaci\u00f3 de fitxers del sistema. NO representa el contingut de cap fitxer, sin\u00f3 la ruta del sistema on es localitza el fitxer. Com que es tracta d\u2019una ruta, la classe pot representar tant fitxers com carpetes o directoris . Si fem servir una classe per a representar rutes, s\u2019aconsegueix una total independ\u00e8ncia respecte de la notaci\u00f3 que utilitza cada sistema operatiu per descriure-les. Recordem que Java i Kotlin s\u00f3n llenguatges multiplataforma i, per tant, s'ha d'intentar fer programes que es puguen executar en qualsevol Sistema Operatiu (Windows o Linux). L\u2019estrat\u00e8gia utilitzada per cada SO no afecta la funcionalitat de la classe File , ja que aquesta, en col\u00b7laboraci\u00f3 amb la m\u00e0quina virtual, adaptar\u00e0 les sol\u00b7licituds al SO amfitri\u00f3 de forma transparent al programador , \u00e9s a dir, sense necessitat que el programador haja d\u2019indicar o configurar res. Els objectes creats de la classe File es troben estretament vinculats a la ruta amb la qual s\u2019han creat. Aix\u00f2 significa que les inst\u00e0ncies de la classe File durant tot el seu cicle de vida nom\u00e9s representaran una \u00fanica ruta, la que se\u2019ls va associar en el moment de la creaci\u00f3. La classe File no disposa de cap m\u00e8tode ni mecanisme per modificar la ruta associada. En cas de necessitar noves rutes, caldr\u00e0 sempre crear un nou objecte i no ser\u00e0 possible reutilitzar els ja creats vinculant-los a rutes diferents. Per a crear un objecte File es pot utilitzar qualsevol dels 3 constructors seg\u00fcents: File(String directori_i_fitxer ) : indiquem en un \u00fanic par\u00e0metre tant el directori com el fitxer, \u00e9s a dir, el fitxer amb la seua ruta. Recordeu que en sistemes Linux per a la ruta utilitzem la barra de dividir, mentre que en Windows la contra-barra. Com que aquest car\u00e0cter \u00e9s el d' escape , s'haur\u00e0 de posar dues vegades: val fitxer_1 = File(\"/home/usuari/AD/T1/exemple1.txt\") val fitxer_1 = File(\"C:\\\\\\AD\\\\\\T1\\\\\\exemple1.txt\") Nota Cap de les refer\u00e8ncies anteriors s\u00f3n desitjables, ja que nosaltres intentarem fer programes que funcionen en qualsevol plataforma, i la primera refer\u00e8ncia no funcionar\u00e0 en Windows, i la segona no funcionar\u00e0 en Linux. Al llarg del tema aprendrem com fer les refer\u00e8ncies de manera que funcionen en qualsevol plataforma. Per una altra banda, observeu com hem utilitzat la paraula reservada val per a crear una constant. Quasi sempre la utilitzarem per als File, ja que nom\u00e9s en algunes ocasions voldrem reutilitzar la variable assignant-li un altre valor Per a fer refer\u00e8ncia a un directori s'utilitza la mateixa t\u00e8cnica, com ja hav\u00edem vist: val dir = File(\"/home/usuari/AD/T1\") En els exemples anteriors hem posat una ruta absoluta, que comen\u00e7a des de l'arrel. Si no la posem absoluta (si no comen\u00e7a per / ) ser\u00e0 relativa i comen\u00e7ar\u00e0 en el directori actiu. Si suposem que el directori actiu \u00e9s /home/usuari , d'aquesta manera far\u00edem refer\u00e8ncia al mateix lloc: val dir = File(\"AD/T1\"); Nota Observeu que les anteriors sent\u00e8ncies no donarien cap error encara que els subdirectoris i fitxers no existisquen. No \u00e9s cap contradicci\u00f3, ja que podria ser que f\u00e9rem refer\u00e8ncia en un File a un fitxer o directori justament per a crear-lo. M\u00e9s avant veurem que tenim m\u00e8todes per a detectar l'exist\u00e8ncia real File(String directori , String fitxer ) : en el primer par\u00e0metre (String) indiquem el directori amb ruta, i en el segon el fitxer (sense ruta). Far\u00e0 refer\u00e8ncia a un fitxer amb el nom com el segon par\u00e0metre col\u00b7locat en el directori referenciat en el primer par\u00e0metre. Observeu com el segon par\u00e0metre podria ser tamb\u00e9 un directori, i per tant seria una refer\u00e8ncia a un subdirectori del directori referenciat en el primer par\u00e0metre. val fitxer_2 = File(\"/home/usuari/AD/T1\" , \"exemple2.txt\") File(File directori , String fitxer ) : Ara el directori \u00e9s un File creat anteriorment val fitxer_3 = File(dir , \"exemple3.txt\") En els exemples anteriors hem posat directament les rutes. Per\u00f2 els programadors de Java i de Kotlin han de fer un esfor\u00e7 per independitzar les aplicacions implementades de les plataformes on s\u2019executaran. Per tant, haurem d'anar amb cura, fent servir t\u00e8cniques que eviten escriure les rutes directament al codi. Per aix\u00f2 encara que ara al principi utilitzarem els 3 constructors, en el futur haur\u00edem d'utilitzar massivament el tercer, ja que com veieu la manera d'especificar la ruta de localitzaci\u00f3 del fitxer, \u00e9s per mig d'un altre File, i no ha fet falta posar cap barra de dividir ni cap contra-barra. Per tant hem fet refer\u00e8ncia a un fitxer (o subdirectori) dins d'un directori sense cap barra ni contra-barra , i per tant ens val per qualsevol Sistema Operatiu. La classe File encapsula pr\u00e0cticament tota la funcionalitat necess\u00e0ria per gestionar un sistema de fitxers organitzat en arbre de directoris. \u00c9s una gesti\u00f3 completa que inclou: Funcions de manipulaci\u00f3 i consulta de la pr\u00f2pia estructura jer\u00e0rquica (creaci\u00f3, eliminaci\u00f3, obtenci\u00f3 de la ubicaci\u00f3, etc. de fitxers o directoris) Funcions de manipulaci\u00f3 i consulta de les caracter\u00edstiques particulars dels elements (noms, mida o capacitat, etc.) Funcions de manipulaci\u00f3 i consulta d\u2019atributs espec\u00edfics de cada Sistema Operatiu, com per exemple els permisos d\u2019escriptura, d\u2019execuci\u00f3, atributs d\u2019ocultaci\u00f3. Nom\u00e9s funcionar\u00e0 si el sistema operatiu amfitri\u00f3 suporta tamb\u00e9 la funcionalitat d'aquestos atributs. En la classe original de Java no ens permet accedir al contingut dels fitxers. Aix\u00f2 es resoldr\u00e0 en el seg\u00fcent tema. Kotlin s\u00ed que ens permetr\u00e0 accedir al contingut dels fitxers a partir de la classe File, per\u00f2 per coher\u00e8ncia ho deixarem per al proper tema. Nota Tots els exemples i exercicis de cada tema els col\u00b7locarem en un \u00fanic projecte de Kotlin amb el nom del tema. en aquest cas l'anomenarem Tema1 . Els exemples els col\u00b7locarem en un paquet anomenat exemple i els exercicis en un paquet anomenat exercicis . En l'apartat Instala.laci\u00f3 de IntelliJ IDEA Ultimate d'aquest tema, hi ha un v\u00eddeo que explica la instal\u00b7laci\u00f3 de l'entorn de programaci\u00f3, i al final d'aquest v\u00eddeo s'explica com crear el projecte, els paquets exemples i exercicis i com copiar els programes en un fitxer Kotlin. Mirem un exemple. Anem a fer un programa per a traure la llista de fitxers i directoris del directori actual. Per a fer refer\u00e8ncia al directori actual, utilitzarem \".\", que ens serveix per a tots els Sistemes. Per defecte, el directori actiu \u00e9s el directori del projecte. Per a obtenir la llista d'elements (fitxers i directoris) utilitzarem el m\u00e8tode list() de la classe File . Veurem aquest m\u00e8tode, juntament amb els m\u00e8todes m\u00e9s importants en la seg\u00fcent pregunta. Copieu-vos el seg\u00fcent en un fitxer Kotlin anomenat Exemple_1_1.kt package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list()) println(e); } I aquest seria el resultat: que s\u00f3n els fitxers del directori arrel del projecte Tema1 (situat en la carpeta IdeaProjects ). Observeu que fins i tot mostra els fitxers ocults (que s\u00f3n els que comencen per un punt) I aprofitant la potencialitat de Kotlin, podem traure f\u00e0cilment aquesta llista ordenada alfab\u00e8ticament, senzillament posant .sorted() . D'aquesta manera, el programa anterior Exemple_1_1.kt ens quedar\u00e0 ara: package exemples import java.io.File fun main(args: Array<String>) { val f = File(\".\") println(\"Llista de fitxers i directoris del directori actual\") println(\"---------------------------------------------------\") for (e in f.list().sorted()) println(e); } I aquest seria el resultat: Si vulgu\u00e9rem traure el contingut d'un directori concret, el posar\u00edem en el moment de definir el File, en compte del punt per a indicar el directori actual. Una altra modificaci\u00f3 seria demanar per teclat el directori del qual volem mostrar el contingut. Copieu el seg\u00fcent codi en el fitxer Kotlin Exemple_1_2.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.list().sorted()) System.out.println(e); } Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"2.- La classe File. Generalitats."},{"location":"AD_T1_Sistema_de_fitxers/3_funcionalitat_de_la_classe_file/","text":"3.- Funcionalitat de la classe File La classe File cont\u00e9 una s\u00e8rie de m\u00e8todes que ens permeten traure informaci\u00f3 relativa al fitxer o directori al que apunta, aix\u00ed com poder navegar (obtenint el pare o accedint a algun dels directoris fills). Tamb\u00e9 ens permetran manipular ambdues coses, modificant la informaci\u00f3 i l'estructura de directoris (crear directoris nous, esborrar, canviar el nom, ...). Veurem alguns d'ells, agrupats per categories. Per cert, com que ens interessa fer les aplicacions sense haver de dependre de la plataforma, ens ser\u00e0 molt \u00fatil poder situar-nos en l'arrel del dispositiu sense haver de posar-lo a m\u00e0. Aix\u00f2 s'aconsegueix amb el m\u00e8tode static de File anomenat listRoots() . En sistemes Linux tornar\u00e0 un \u00fanic element, per\u00f2 en sistemes Windows tornar\u00e0 l'arrel de cada unitat del sistema, per aix\u00f2 \u00e9s un array. Aquesta \u00e9s una manera d'obtenir un File que apunta a l'arrel (i en el cas de Windows a l'arrel de C:): val f = File.listRoots()[0] Si en Windows vulgu\u00e9rem anar a l'arrel de D: , haur\u00edem de posar File.listRoots() [1] , i aix\u00ed successivament. Una altra cosa que pot dur a engany \u00e9s que perfectament pot no existir el fitxer o directori especificat en la creaci\u00f3 del File. Recordeu que no estem accedint encara al contingut dels fitxers. I perfectament podem crear un File d'un fitxer o directori que no existeix, justament per a crear-lo. M\u00e8todes per a obtenir el nom o la ruta getName() Torna el nom del fitxer o directori getPath() Torna la ruta (relativa) getAbsolutePath() Torna la ruta absoluta getCanonicalPath() Torna la ruta absoluta sense possibles redund\u00e0ncies getPath() d\u00f3na la ruta fins arribar al fitxer, per\u00f2 relativa, tal i com s'especifica en el moment de crear el File. getAbsolutePath() d\u00f3na la ruta absoluta, des de l'arrel. En determinades ocasions poden haver redund\u00e0ncies en la ruta getCanonicalPath() d\u00f3na la ruta absoluta, des de l'arrel, i sense redund\u00e0ncies. T\u00e9 com a inconvenient una utilitzaci\u00f3 m\u00e9s complicada que getAbsolutePath. En el seg\u00fcent exemple s'intenta mostrar aix\u00f2 de les redund\u00e0ncies, que getCanonicalPath() resol completament. Observeu com per a il\u00b7lustrar l'exemple fem refer\u00e8ncia a un fitxer d'una forma complicada. Suposem que el directori actiu \u00e9s /home/usuari/workspace/Tema1 , i volem fer refer\u00e8ncia a un fitxer situat en un subdirectori anomenat fitxers . Si copiem el seg\u00fcent codi en el fitxer Exemple_1_3.kt : package exemples import java.io.File fun main(args: Array<String>) { val f = File(\"fitxers/../fitxers/f1.txt\") println(\"Nom del fitxer: \" + f.getName()) println(\"Ruta del fitxer: \" + f.getPath()) println(\"Ruta absoluta del fitxer: \" + f.getAbsolutePath()) println(\"Ruta can\u00f2nica del fitxer: \" + f.getCanonicalPath()) } Si suposem que el directori actiu \u00e9s /home/usuari/IdeaProjects/Tema1 (recordeu que per defecte el directori actiu \u00e9s el directori on est\u00e0 el projecte), el resultat ser\u00e0: Nom del fitxer: f1.txt Ruta del fitxer: fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/f1.txt Recordeu que no cal que existesca el fitxer f1.txt , o el subdirectori fitxers . M\u00e8todes per a obtenir els fills o el pare list() Torna un array de Strings amb els noms de tots els elements continguts en el File listFiles() Torna un array de Files amb tots els elements continguts en el File getParent() Torna el nom (string) del pare (si no existeix per ser l'arrel, tornar\u00e0 nul) getParentFile() Torna el pare com un File (si no existeix per ser l'arrel, tornar\u00e0 nul) Ja hem vist la utilitat de list() , que torna un array de strings. En ocasions ens ser\u00e0 de molt\u00edssima utilitat listFiles() , ja que torna un array de Files. Si a a\u00e7\u00f2 adjuntem els m\u00e8todes getParent() i getParentFile() , veiem que podrem navegar pel sistema de fitxers. M\u00e8todes per veure l'exist\u00e8ncia i caracter\u00edstiques exists() Torna true si el fitxer o directori existeix isDirectory() Torna true si \u00e9s un directori isFile() Torna true si \u00e9s un fitxer length() Torna la grand\u00e0ria del fitxer en bytes lastModified() Torna la data de modificaci\u00f3 del fitxer o directori setLastModified() Actualitza la data de modificaci\u00f3 del fitxer o directori Com ja hav\u00edem comentat abans, en el moment de crear el File, pot ser existesca o no el fitxer o directori, \u00e9s a dir, que potser es corresponga o no amb un fitxer real. Si volem comprovar l'exist\u00e8ncia podem utilitzar el m\u00e8tode exists() . Anem a modificar l'exemple 2, on torn\u00e0vem tots els fitxers i directoris d'un directori introdu\u00eft per teclat. Primer ens assegurem que existeix i \u00e9s un directori. Despr\u00e9s el millorarem tornant la grand\u00e0ria de cada fitxer si \u00e9s un fitxer, i especificant que \u00e9s un directori, si ho \u00e9s. Ens convindr\u00e0 listFiles() per a poder mirar si \u00e9s un fitxer o directori, la grand\u00e0ria, ... Tamb\u00e9 hem aprofitat per crear el m\u00e8tode est\u00e0tic llistat(File) , que mostrar\u00e0 el contingut del directori on apunta el File, i aix\u00ed estructurar-lo un poc millor. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_1_4.kt package exemples import java.io.BufferedReader import java.io.File import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) if (f.exists()) { if (f.isDirectory()) { llistaDirectori(f) } else println(\"No \u00e9s un directori\") } else println(\"No existeix el directori\") } fun llistaDirectori(f: File) { val s = \"Llista de fitxers i directoris del directori \" + f.getCanonicalPath() println(s) println(\"-\".repeat(s.length)) for (e in f.listFiles().sorted()) { if (e.isFile()) println(e.getName() + \"\\t \" + e.length()) if (e.isDirectory()) println(e.getName() + \"\\t <Directori>\") } } I aquest seria el resultat si introdu\u00efm el directori actual ( . ) M\u00e8todes per als permisos Els seg\u00fcents m\u00e8todes ens permeten consultar i modificar els permisos del File, al m\u00e9s pur estil Linux canRead() Torna true si es t\u00e9 perm\u00eds de lectura sobre el fitxer o directori canWrite() Torna true si es t\u00e9 perm\u00eds d'escriptura sobre el fitxer o directori canExecute() Torna true si \u00e9s executable setReadable(Boolean,Boolean) D\u00f3na perm\u00eds o no de lectura sobre el fitxer, segons el primer par\u00e0metre. En el segon indiquem si afecta nom\u00e9s al propietari (true) o a tot el m\u00f3n (false) setWritable(Boolean,Boolean) D\u00f3na perm\u00eds d'escriptura o no, segons el valor del primer par\u00e0metre. El segon actua igual que abans setExecutable(Boolean,Boolean) D\u00f3na perm\u00eds d'execuci\u00f3, segons el valor del primer par\u00e0metre. El segon actua igual que abans M\u00e8todes de creaci\u00f3 i esborrat Ens permetran crear diectoris, fitxers buits i esborrar-los createNewFile() Crea un fitxer nou buit associat al File, sempre que no existesca ja un amb el mateix nom delete() Esborra el fitxer o directori mkdir() Crea un directori amb el nom indicat en la creaci\u00f3 del File. Ha d'existir el directori pare mkdirs() Com l'anterior, per\u00f2 si cal crea tots els directoris de la ruta necessaris renameTo(String nou_nom) Canvia el nom del fitxer o directori M\u00e8todes sobre l'espai del dispositiu Tamb\u00e9 disposem de m\u00e8todes que ens diuen l'espai total i lliure del dispositiu on est\u00e0 situat el File getFreeSpace() Torna l'espai lliure del dispositiu on est\u00e0 situat el File getUsableSpace() Torna l'espai utilitzable per l'aplicaci\u00f3 (menor que l'espai lliure) getTotalSpace() Torna l'espai total del dispositiu on est\u00e0 situat el File M\u00e8todes espec\u00edfics de Kotlin Kotlin afegeix funcionalitat a la classe File. Aix\u00ed el seg\u00fcents m\u00e8todes s\u00f3n espec\u00edfics de Kotlin, i no els trobar\u00edem en Java walk() Torna una seq\u00fc\u00e8ncia per a visitar tots els fitxers i subdirectoris, i els seus continguts. Es pot indicar la manera d'accedir als subdirectoris amb par\u00e0mentres. La manera d'actuar per defecte \u00e9s primer mostrar el propi directori, i despr\u00e9s els descendents walkTopDown() El mateix que l'anterior en l'opci\u00f3 per defecte walkBottomUp() Igual que l'anterior, per\u00f2 mostrant abans els descendents i despr\u00e9s el propi directori Per tant s\u00f3n una forma c\u00f2moda per a accedir a tota l'estructura de directoris i fitxers que pengen de l'actual directori. Modificarem l'exemple 2, per a mostrar ara tots els descendents del directori intru\u00eft per teclat. Copieu el seg\u00fcent codi en en un fitxer anomenat Exemple_1_5.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.walk().sorted()) System.out.println(e); } I el resultat seria, si introdu\u00efm el directori actual ( . ): Es pot observar que primer mostra un determinat directori i despr\u00e9s tot el seu contingut. Per exemple ./src est\u00e0 abans que tots els seus descendents. Amb walkBottomUp() seria a l'inrev\u00e8s, per exemple primer tots els descendents de ./src , i despr\u00e9s el propi ./src Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3. Funcionalitat de la classe File"},{"location":"AD_T1_Sistema_de_fitxers/3_funcionalitat_de_la_classe_file/#3-funcionalitat-de-la-classe-file","text":"La classe File cont\u00e9 una s\u00e8rie de m\u00e8todes que ens permeten traure informaci\u00f3 relativa al fitxer o directori al que apunta, aix\u00ed com poder navegar (obtenint el pare o accedint a algun dels directoris fills). Tamb\u00e9 ens permetran manipular ambdues coses, modificant la informaci\u00f3 i l'estructura de directoris (crear directoris nous, esborrar, canviar el nom, ...). Veurem alguns d'ells, agrupats per categories. Per cert, com que ens interessa fer les aplicacions sense haver de dependre de la plataforma, ens ser\u00e0 molt \u00fatil poder situar-nos en l'arrel del dispositiu sense haver de posar-lo a m\u00e0. Aix\u00f2 s'aconsegueix amb el m\u00e8tode static de File anomenat listRoots() . En sistemes Linux tornar\u00e0 un \u00fanic element, per\u00f2 en sistemes Windows tornar\u00e0 l'arrel de cada unitat del sistema, per aix\u00f2 \u00e9s un array. Aquesta \u00e9s una manera d'obtenir un File que apunta a l'arrel (i en el cas de Windows a l'arrel de C:): val f = File.listRoots()[0] Si en Windows vulgu\u00e9rem anar a l'arrel de D: , haur\u00edem de posar File.listRoots() [1] , i aix\u00ed successivament. Una altra cosa que pot dur a engany \u00e9s que perfectament pot no existir el fitxer o directori especificat en la creaci\u00f3 del File. Recordeu que no estem accedint encara al contingut dels fitxers. I perfectament podem crear un File d'un fitxer o directori que no existeix, justament per a crear-lo. M\u00e8todes per a obtenir el nom o la ruta getName() Torna el nom del fitxer o directori getPath() Torna la ruta (relativa) getAbsolutePath() Torna la ruta absoluta getCanonicalPath() Torna la ruta absoluta sense possibles redund\u00e0ncies getPath() d\u00f3na la ruta fins arribar al fitxer, per\u00f2 relativa, tal i com s'especifica en el moment de crear el File. getAbsolutePath() d\u00f3na la ruta absoluta, des de l'arrel. En determinades ocasions poden haver redund\u00e0ncies en la ruta getCanonicalPath() d\u00f3na la ruta absoluta, des de l'arrel, i sense redund\u00e0ncies. T\u00e9 com a inconvenient una utilitzaci\u00f3 m\u00e9s complicada que getAbsolutePath. En el seg\u00fcent exemple s'intenta mostrar aix\u00f2 de les redund\u00e0ncies, que getCanonicalPath() resol completament. Observeu com per a il\u00b7lustrar l'exemple fem refer\u00e8ncia a un fitxer d'una forma complicada. Suposem que el directori actiu \u00e9s /home/usuari/workspace/Tema1 , i volem fer refer\u00e8ncia a un fitxer situat en un subdirectori anomenat fitxers . Si copiem el seg\u00fcent codi en el fitxer Exemple_1_3.kt : package exemples import java.io.File fun main(args: Array<String>) { val f = File(\"fitxers/../fitxers/f1.txt\") println(\"Nom del fitxer: \" + f.getName()) println(\"Ruta del fitxer: \" + f.getPath()) println(\"Ruta absoluta del fitxer: \" + f.getAbsolutePath()) println(\"Ruta can\u00f2nica del fitxer: \" + f.getCanonicalPath()) } Si suposem que el directori actiu \u00e9s /home/usuari/IdeaProjects/Tema1 (recordeu que per defecte el directori actiu \u00e9s el directori on est\u00e0 el projecte), el resultat ser\u00e0: Nom del fitxer: f1.txt Ruta del fitxer: fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/../fitxers/f1.txt Ruta absoluta del fitxer: /home/usuari/IdeaProjects/Tema1/fitxers/f1.txt Recordeu que no cal que existesca el fitxer f1.txt , o el subdirectori fitxers . M\u00e8todes per a obtenir els fills o el pare list() Torna un array de Strings amb els noms de tots els elements continguts en el File listFiles() Torna un array de Files amb tots els elements continguts en el File getParent() Torna el nom (string) del pare (si no existeix per ser l'arrel, tornar\u00e0 nul) getParentFile() Torna el pare com un File (si no existeix per ser l'arrel, tornar\u00e0 nul) Ja hem vist la utilitat de list() , que torna un array de strings. En ocasions ens ser\u00e0 de molt\u00edssima utilitat listFiles() , ja que torna un array de Files. Si a a\u00e7\u00f2 adjuntem els m\u00e8todes getParent() i getParentFile() , veiem que podrem navegar pel sistema de fitxers. M\u00e8todes per veure l'exist\u00e8ncia i caracter\u00edstiques exists() Torna true si el fitxer o directori existeix isDirectory() Torna true si \u00e9s un directori isFile() Torna true si \u00e9s un fitxer length() Torna la grand\u00e0ria del fitxer en bytes lastModified() Torna la data de modificaci\u00f3 del fitxer o directori setLastModified() Actualitza la data de modificaci\u00f3 del fitxer o directori Com ja hav\u00edem comentat abans, en el moment de crear el File, pot ser existesca o no el fitxer o directori, \u00e9s a dir, que potser es corresponga o no amb un fitxer real. Si volem comprovar l'exist\u00e8ncia podem utilitzar el m\u00e8tode exists() . Anem a modificar l'exemple 2, on torn\u00e0vem tots els fitxers i directoris d'un directori introdu\u00eft per teclat. Primer ens assegurem que existeix i \u00e9s un directori. Despr\u00e9s el millorarem tornant la grand\u00e0ria de cada fitxer si \u00e9s un fitxer, i especificant que \u00e9s un directori, si ho \u00e9s. Ens convindr\u00e0 listFiles() per a poder mirar si \u00e9s un fitxer o directori, la grand\u00e0ria, ... Tamb\u00e9 hem aprofitat per crear el m\u00e8tode est\u00e0tic llistat(File) , que mostrar\u00e0 el contingut del directori on apunta el File, i aix\u00ed estructurar-lo un poc millor. Copieu el seg\u00fcent codi en un fitxer anomenat Exemple_1_4.kt package exemples import java.io.BufferedReader import java.io.File import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) if (f.exists()) { if (f.isDirectory()) { llistaDirectori(f) } else println(\"No \u00e9s un directori\") } else println(\"No existeix el directori\") } fun llistaDirectori(f: File) { val s = \"Llista de fitxers i directoris del directori \" + f.getCanonicalPath() println(s) println(\"-\".repeat(s.length)) for (e in f.listFiles().sorted()) { if (e.isFile()) println(e.getName() + \"\\t \" + e.length()) if (e.isDirectory()) println(e.getName() + \"\\t <Directori>\") } } I aquest seria el resultat si introdu\u00efm el directori actual ( . ) M\u00e8todes per als permisos Els seg\u00fcents m\u00e8todes ens permeten consultar i modificar els permisos del File, al m\u00e9s pur estil Linux canRead() Torna true si es t\u00e9 perm\u00eds de lectura sobre el fitxer o directori canWrite() Torna true si es t\u00e9 perm\u00eds d'escriptura sobre el fitxer o directori canExecute() Torna true si \u00e9s executable setReadable(Boolean,Boolean) D\u00f3na perm\u00eds o no de lectura sobre el fitxer, segons el primer par\u00e0metre. En el segon indiquem si afecta nom\u00e9s al propietari (true) o a tot el m\u00f3n (false) setWritable(Boolean,Boolean) D\u00f3na perm\u00eds d'escriptura o no, segons el valor del primer par\u00e0metre. El segon actua igual que abans setExecutable(Boolean,Boolean) D\u00f3na perm\u00eds d'execuci\u00f3, segons el valor del primer par\u00e0metre. El segon actua igual que abans M\u00e8todes de creaci\u00f3 i esborrat Ens permetran crear diectoris, fitxers buits i esborrar-los createNewFile() Crea un fitxer nou buit associat al File, sempre que no existesca ja un amb el mateix nom delete() Esborra el fitxer o directori mkdir() Crea un directori amb el nom indicat en la creaci\u00f3 del File. Ha d'existir el directori pare mkdirs() Com l'anterior, per\u00f2 si cal crea tots els directoris de la ruta necessaris renameTo(String nou_nom) Canvia el nom del fitxer o directori M\u00e8todes sobre l'espai del dispositiu Tamb\u00e9 disposem de m\u00e8todes que ens diuen l'espai total i lliure del dispositiu on est\u00e0 situat el File getFreeSpace() Torna l'espai lliure del dispositiu on est\u00e0 situat el File getUsableSpace() Torna l'espai utilitzable per l'aplicaci\u00f3 (menor que l'espai lliure) getTotalSpace() Torna l'espai total del dispositiu on est\u00e0 situat el File M\u00e8todes espec\u00edfics de Kotlin Kotlin afegeix funcionalitat a la classe File. Aix\u00ed el seg\u00fcents m\u00e8todes s\u00f3n espec\u00edfics de Kotlin, i no els trobar\u00edem en Java walk() Torna una seq\u00fc\u00e8ncia per a visitar tots els fitxers i subdirectoris, i els seus continguts. Es pot indicar la manera d'accedir als subdirectoris amb par\u00e0mentres. La manera d'actuar per defecte \u00e9s primer mostrar el propi directori, i despr\u00e9s els descendents walkTopDown() El mateix que l'anterior en l'opci\u00f3 per defecte walkBottomUp() Igual que l'anterior, per\u00f2 mostrant abans els descendents i despr\u00e9s el propi directori Per tant s\u00f3n una forma c\u00f2moda per a accedir a tota l'estructura de directoris i fitxers que pengen de l'actual directori. Modificarem l'exemple 2, per a mostrar ara tots els descendents del directori intru\u00eft per teclat. Copieu el seg\u00fcent codi en en un fitxer anomenat Exemple_1_5.kt package exemples import java.io.File import java.io.BufferedReader import java.io.InputStreamReader fun main(args: Array<String>) { println(\"Introdueix un directori:\") val ent = BufferedReader(InputStreamReader(System.`in`)).readLine() val f = File(ent) System.out.println(\"Llista de fitxers i directoris del directori \" + ent) System.out.println(\"---------------------------------------------------\") for (e in f.walk().sorted()) System.out.println(e); } I el resultat seria, si introdu\u00efm el directori actual ( . ): Es pot observar que primer mostra un determinat directori i despr\u00e9s tot el seu contingut. Per exemple ./src est\u00e0 abans que tots els seus descendents. Amb walkBottomUp() seria a l'inrev\u00e8s, per exemple primer tots els descendents de ./src , i despr\u00e9s el propi ./src Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"3.- Funcionalitat de la classe File"},{"location":"AD_T1_Sistema_de_fitxers/Idea/","text":"Instal.laci\u00f3 de IntelliJ Idea Ultimate Tots els nostres programes seran en KOTLIN , que \u00e9s un llenguatge que est\u00e0 per damunt de Java, de manera que tots els programes, classes... realitzats en Java els podrem utilitzar sense problemes, i a m\u00e9s ens permetr\u00e0 una programaci\u00f3 molt m\u00e9s c\u00f2moda. A m\u00e9s, \u00e9s el llenguatge que utilitzareu tant en el m\u00f2dul de PMDM com en el de DI Com a pas previ i inicial instal\u00b7larem l'entorn de treball des d'on programarem, un IDE. Enguany instal\u00b7larem IntelliJ IDEA , la versi\u00f3 Ultimate , que \u00e9s la que ens proporcionar\u00e0 totes les eines per a poder treballar sense problemes. Un altre entorn molt habitual \u00e9s Eclipse , que \u00e9s el que hem utilitzat en anys anteriors, per\u00f2 que amb el plugin de Kotlin va molt lent. En IntelliJ vaja molt m\u00e9s fi. En el moment de fer aquestos apunts l'\u00faltima versi\u00f3 \u00e9s la 2022.2.1. El seg\u00fcent v\u00eddeo mostra tot el proc\u00e9s d'instal\u00b7laci\u00f3 i creaci\u00f3 del primer projecte. Correspon a una versi\u00f3 anterior, per\u00f2 totalment similar a l'actual Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Instal.laci\u00f3 de IntelliJ Idea Ultimate"},{"location":"AD_T1_Sistema_de_fitxers/Idea/#installacio-de-intellij-idea-ultimate","text":"Tots els nostres programes seran en KOTLIN , que \u00e9s un llenguatge que est\u00e0 per damunt de Java, de manera que tots els programes, classes... realitzats en Java els podrem utilitzar sense problemes, i a m\u00e9s ens permetr\u00e0 una programaci\u00f3 molt m\u00e9s c\u00f2moda. A m\u00e9s, \u00e9s el llenguatge que utilitzareu tant en el m\u00f2dul de PMDM com en el de DI Com a pas previ i inicial instal\u00b7larem l'entorn de treball des d'on programarem, un IDE. Enguany instal\u00b7larem IntelliJ IDEA , la versi\u00f3 Ultimate , que \u00e9s la que ens proporcionar\u00e0 totes les eines per a poder treballar sense problemes. Un altre entorn molt habitual \u00e9s Eclipse , que \u00e9s el que hem utilitzat en anys anteriors, per\u00f2 que amb el plugin de Kotlin va molt lent. En IntelliJ vaja molt m\u00e9s fi. En el moment de fer aquestos apunts l'\u00faltima versi\u00f3 \u00e9s la 2022.2.1. El seg\u00fcent v\u00eddeo mostra tot el proc\u00e9s d'instal\u00b7laci\u00f3 i creaci\u00f3 del primer projecte. Correspon a una versi\u00f3 anterior, per\u00f2 totalment similar a l'actual Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Instal.laci\u00f3 de IntelliJ Idea Ultimate"},{"location":"AD_T1_Sistema_de_fitxers/exercici/","text":"Exercici 1 Realitza un programa en un fitxer anomenat Exercici_1.kt en el paquet exercicis , que permeta navegar pels directoris de la unitat principal del sistema d'arxius. Ha de comen\u00e7ar per l'arrel (/ en Linux; c:\\ en Windows). Recordeu que el m\u00e8tode est\u00e0tic File.listRoots()[0] ens d\u00f3na l'arrel. Ha d'indicar el directori que est\u00e0 mostrant. Ha de posar com a primera opci\u00f3 anar al directori pare (opci\u00f3 0). Ha de posar un n\u00famero davant de cada arxiu o subdirectori que s'est\u00e0 mostrant. Observeu que aquest n\u00famero comen\u00e7a amb 1 (el 0 \u00e9s per al pare). Si us heu guardat en un array la llista de fitxers i directoris del directori actual, recordeu que el primer element \u00e9s el 0 (per\u00f2 vosaltres el mostrareu amb un 1 davant). En cas de ser un arxiu ha de dir la grand\u00e0ria. En cas de ser un subdirectori, ha d'indicar-lo amb < directori> Posteriorment ha de deixar introduir un n\u00famero. Les opcions seran: -1 per acabar 0 anar al directori pare. Si s'ha triat el 0 (per anar al pare) s'ha de controlar que existeix el pare (en el cas de l'arrel, no en t\u00e9). Si no en t\u00e9, no s'ha de fer res. Qualsevol altre n\u00famero ha de servir per canviar a aquest directori com a directori actiu. Si era un fitxer, no ha de fer res (en la imatge, no s'ha de poder anar al 9, ja que \u00e9s un fitxer). S'ha de controlar que hi ha perm\u00eds de lectura sobre un directori, abans de canviar a ell, sin\u00f3 donar\u00e0 error (en la imatge, per exemple, segurament no es podr\u00e0 canviar al directori root , ja que no tindrem perm\u00eds de lectura sobre ell). Aquesta comprovaci\u00f3 s'ha de fer abans de canviar al directori triat. I s'ha de controlar que el n\u00famero introdu\u00eft est\u00e0 en el rang correcte (en la imatge, de -1 fins a 28) La seg\u00fcent imatge mostra el resultat: Voluntari Modifica l'anterior per a que tamb\u00e9 ens proporcione dades sobre si \u00e9s un directori, els permisos, grand\u00e0ria i data de modificaci\u00f3 a l'estil de Linux quan fas ls -l . L'aspecte podria ser aquest: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Exercici"},{"location":"AD_T1_Sistema_de_fitxers/exercici/#exercici-1","text":"Realitza un programa en un fitxer anomenat Exercici_1.kt en el paquet exercicis , que permeta navegar pels directoris de la unitat principal del sistema d'arxius. Ha de comen\u00e7ar per l'arrel (/ en Linux; c:\\ en Windows). Recordeu que el m\u00e8tode est\u00e0tic File.listRoots()[0] ens d\u00f3na l'arrel. Ha d'indicar el directori que est\u00e0 mostrant. Ha de posar com a primera opci\u00f3 anar al directori pare (opci\u00f3 0). Ha de posar un n\u00famero davant de cada arxiu o subdirectori que s'est\u00e0 mostrant. Observeu que aquest n\u00famero comen\u00e7a amb 1 (el 0 \u00e9s per al pare). Si us heu guardat en un array la llista de fitxers i directoris del directori actual, recordeu que el primer element \u00e9s el 0 (per\u00f2 vosaltres el mostrareu amb un 1 davant). En cas de ser un arxiu ha de dir la grand\u00e0ria. En cas de ser un subdirectori, ha d'indicar-lo amb < directori> Posteriorment ha de deixar introduir un n\u00famero. Les opcions seran: -1 per acabar 0 anar al directori pare. Si s'ha triat el 0 (per anar al pare) s'ha de controlar que existeix el pare (en el cas de l'arrel, no en t\u00e9). Si no en t\u00e9, no s'ha de fer res. Qualsevol altre n\u00famero ha de servir per canviar a aquest directori com a directori actiu. Si era un fitxer, no ha de fer res (en la imatge, no s'ha de poder anar al 9, ja que \u00e9s un fitxer). S'ha de controlar que hi ha perm\u00eds de lectura sobre un directori, abans de canviar a ell, sin\u00f3 donar\u00e0 error (en la imatge, per exemple, segurament no es podr\u00e0 canviar al directori root , ja que no tindrem perm\u00eds de lectura sobre ell). Aquesta comprovaci\u00f3 s'ha de fer abans de canviar al directori triat. I s'ha de controlar que el n\u00famero introdu\u00eft est\u00e0 en el rang correcte (en la imatge, de -1 fins a 28) La seg\u00fcent imatge mostra el resultat:","title":"Exercici 1"},{"location":"AD_T1_Sistema_de_fitxers/exercici/#voluntari","text":"Modifica l'anterior per a que tamb\u00e9 ens proporcione dades sobre si \u00e9s un directori, els permisos, grand\u00e0ria i data de modificaci\u00f3 a l'estil de Linux quan fas ls -l . L'aspecte podria ser aquest: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Voluntari"},{"location":"AD_T1_Sistema_de_fitxers/objectius/","text":"Objectius L'objectiu del primer tema \u00e9s senzillament arribar als fitxers, per\u00f2 no al seu contingut, que es veur\u00e0 en el proper tema. Tan sols arribarem a \"veure\" el fitxer, amb la seua ruta. De fet la manera d'arribar a un directori i a un fitxer ser\u00e0 id\u00e8ntica. I del fitxer o directori podrem arribar a veure i tamb\u00e9 modificar les caracter\u00edstiques externes: nom, grand\u00e0ria, data d'\u00faltima modificaci\u00f3, permisos, ... \u00c9s un tema molt curtet que es podria haver englobat amb els dos temes seg\u00fcents, tamb\u00e9 de fitxers. Per\u00f2 hem preferit separar-lo per ser principi de curs, per a poder anar \"rodant\" sense presses. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"},{"location":"AD_T1_Sistema_de_fitxers/objectius/#objectius","text":"L'objectiu del primer tema \u00e9s senzillament arribar als fitxers, per\u00f2 no al seu contingut, que es veur\u00e0 en el proper tema. Tan sols arribarem a \"veure\" el fitxer, amb la seua ruta. De fet la manera d'arribar a un directori i a un fitxer ser\u00e0 id\u00e8ntica. I del fitxer o directori podrem arribar a veure i tamb\u00e9 modificar les caracter\u00edstiques externes: nom, grand\u00e0ria, data d'\u00faltima modificaci\u00f3, permisos, ... \u00c9s un tema molt curtet que es podria haver englobat amb els dos temes seg\u00fcents, tamb\u00e9 de fitxers. Per\u00f2 hem preferit separar-lo per ser principi de curs, per a poder anar \"rodant\" sense presses. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Objectius"}]}